// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: v1/example.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../google/protobuf/any";
import { Duration } from "../google/protobuf/duration";
import { Timestamp } from "../google/protobuf/timestamp";

export const protobufPackage = "example.v1";

/** 非推奨のフィールドを使いたいとき */
export interface DeprecatedExample {
  /**
   * 非推奨のフィールドを使いたいとき
   *
   * @deprecated
   */
  deprecatedValue: string;
}

/** oneofフィールドのうち、どれか一つは必須にしたいとき */
export interface OneofExample {
  val1?: string | undefined;
  val2?: string | undefined;
}

/** ignore_empty */
export interface IgnoreEmptyExample {
  /** Stingなら空文字列、int32ならゼロ値のようにdefault値を持つフィールドを無視したいとき */
  val1: string;
  /** 常にバリデーションをスキップする */
  val2: string;
  /**
   * リクエストボディに値がないときだけバリデーションをスキップする
   * ただし、リクエストボディに値がある場合はバリデーションを実行する
   */
  val3: string;
}

/** 各種文字列バリデーションを試したいとき */
export interface StringValidationExample {
  /** 特定の文字列のみ許可したいとき */
  constValue: string;
  /** 長さをちょうどN文字にしたいとき */
  lenValue: string;
  /** 最低N文字にしたいとき */
  minLenValue: string;
  /** 最大N文字にしたいとき */
  maxLenValue: string;
  /** バイト長でちょうどNにしたいとき */
  lenBytesValue: string;
  /** バイト長が最低N以上にしたいとき */
  minBytesValue: string;
  /** バイト長が最大N以下にしたいとき */
  maxBytesValue: string;
  /** 正規表現にマッチさせたいとき */
  patternValue: string;
  /** 特定の接頭辞を持たせたいとき */
  prefixValue: string;
  /** 特定の接尾辞を持たせたいとき */
  suffixValue: string;
  /** 特定の文字列を含ませたいとき */
  containsValue: string;
  /** 特定の文字列を含まないようにしたいとき */
  notContainsValue: string;
  /** 限定された候補の中からのみ選ばせたいとき */
  inValue: string;
  /** 指定の値以外を許可したいとき */
  notInValue: string;
  /** email形式かをチェックしたいとき */
  emailValue: string;
  /** ホスト名形式であることを確認したいとき */
  hostnameValue: string;
  /** IPアドレス全般の形式を許容したいとき */
  ipValue: string;
  /** IPv4形式のみ許容したいとき */
  ipv4Value: string;
  /** IPv6形式のみ許容したいとき */
  ipv6Value: string;
  /** URI形式を確認したいとき */
  uriValue: string;
  /** URI参照の形式を確認したいとき */
  uriRefValue: string;
  /** アドレス形式（IPまたはホスト名）かを確認したいとき */
  addressValue: string;
  /** UUID形式を確認したいとき */
  uuidValue: string;
  /** 短縮UUID（TUUID）形式を確認したいとき */
  tuuidValue: string;
  /** IP + プレフィックス長の形式を許容したいとき */
  ipWithPreifxlenValue: string;
  ipv4WithPreifxlenValue: string;
  ipv6WithPreifxlenValue: string;
  ipPrefixValue: string;
  ip4PrefixValue: string;
  ip6PrefixValue: string;
  /** ホスト名とポート番号の形式であることを確認したいとき */
  hostAndPortValue: string;
  /** KnownRegexによる事前定義済みのパターンで検証したいとき */
  wellKownRegexValue: string;
}

/** bool型の値を制限したいとき */
export interface BoolValidationExample {
  /** 真偽値がtrueに限定されるとき */
  trueValue: boolean;
  /** 真偽値がfalseに限定されるとき */
  falseValue: boolean;
}

/** バイナリデータの内容や長さを制限したいとき */
export interface BytesValidationExample {
  /** 固定のバイト列のみ許可したいとき */
  constValue: Uint8Array;
  /** 長さをちょうどにしたいとき */
  lenValue: Uint8Array;
  /** 最小バイト数にしたいとき */
  minLenValue: Uint8Array;
  /** 最大バイト数にしたいとき */
  maxLenValue: Uint8Array;
  /** 正規表現でバイナリを制限したいとき */
  patternValue: Uint8Array;
  /** 指定したバイナリ接頭辞を持たせたいとき */
  prefixValue: Uint8Array;
  /** 指定したバイナリ接尾辞を持たせたいとき */
  suffixValue: Uint8Array;
  /** 特定のバイト列を含めたいとき */
  containsValue: Uint8Array;
  /** 指定の候補だけ許容したいとき */
  inValue: Uint8Array;
  /** 指定の候補以外を許容したいとき */
  notInValue: Uint8Array;
  /** バイナリがIP形式のとき */
  ipValue: Uint8Array;
  /** IPv4形式のとき */
  ipv4Value: Uint8Array;
  /** IPv6形式のとき */
  ipv6Value: Uint8Array;
}

/** 数値（浮動小数点）の条件をつけたいとき */
export interface DoubleValidationExample {
  /** 値が 42.0 である必要がある */
  constValue: number;
  /** 10.0 より小さい値である必要がある（9.9など） */
  ltValue: number;
  /** 10.0 以下の値である必要がある（10.0もOK） */
  lteValue: number;
  /** 10.0 より大きい値である必要がある（10.1など） */
  gtValue: number;
  /** 10.0 以上の値である必要がある（10.0もOK） */
  gteValue: number;
  /** 10.0, 11.0, 12.0 のいずれかでなければならない */
  inValue: number;
  /** 10.0, 11.0, 12.0 は使用禁止（それ以外の値ならOK） */
  notInValue: number;
  /** 無限大や NaN を拒否したいとき（finite = true） */
  finiteValue: number;
}

/** Mapのサイズやキー・値の制約をしたいとき */
export interface MapValidationExample {
  minPairsValue: { [key: string]: string };
  maxPairsValue: { [key: string]: string };
  keysValue: { [key: string]: string };
  valuesValue: { [key: string]: string };
}

export interface MapValidationExample_MinPairsValueEntry {
  key: string;
  value: string;
}

export interface MapValidationExample_MaxPairsValueEntry {
  key: string;
  value: string;
}

export interface MapValidationExample_KeysValueEntry {
  key: string;
  value: string;
}

export interface MapValidationExample_ValuesValueEntry {
  key: string;
  value: string;
}

/** 繰り返しフィールドの制約をかけたいとき */
export interface RepeatedValidationExample {
  /** 繰り返しフィールドの最小要素数を指定したいとき */
  minItemsValue: string[];
  /** 繰り返しフィールドの最大要素数を指定したいとき */
  maxItemsValue: string[];
  /** 繰り返しフィールドの要素に対して、ユニークな値を要求したいとき */
  uniqueValue: string[];
  /** 繰り返しフィールドの要素に対して、特定の長さを要求したいとき */
  itemsValue: string[];
}

/** Any型のタイプを制限したいとき */
export interface AnyValidationExample {
  /**
   * int32やstringのAny型を許可したいとき
   * ただし、Any型の中身はint32やstringである必要がある
   */
  inValue:
    | Any
    | undefined;
  /**
   * int32やstringのAny型を許可したくないとき
   * ただし、Any型の中身はint32やstring 以外である必要がある
   */
  notInValue: Any | undefined;
}

/**
 * Durationの比較をしたいとき
 * Durationの比較をしたいとき
 */
export interface DurationValidationExample {
  /** 指定された秒数と正確に一致している必要があるとき */
  constValue:
    | Duration
    | undefined;
  /** 指定された秒数より短い必要があるとき */
  ltValue:
    | Duration
    | undefined;
  /** 指定された秒数以下である必要があるとき */
  lteValue:
    | Duration
    | undefined;
  /** 指定された秒数より長い必要があるとき */
  gtValue:
    | Duration
    | undefined;
  /** 指定された秒数以上である必要があるとき */
  gteValue:
    | Duration
    | undefined;
  /** 指定された複数の候補の中のいずれかに一致している必要があるとき */
  inValue:
    | Duration
    | undefined;
  /** 指定された複数の値以外でなければならないとき */
  notInValue: Duration | undefined;
}

/** 列挙型（enum）の値制限をしたいとき */
export interface EnumValidationExample {
  /** 特定の値だけを許可 */
  constValue: EnumValidationExample_MyEnum;
  /** enumに定義された値のみ許可（未定義の数値はエラー） */
  definedOnlyValue: EnumValidationExample_MyEnum;
  /** 指定した値（1または2）のみ許容 */
  inValue: EnumValidationExample_MyEnum;
  /** 指定した値（1と2）以外のみ許容 */
  notInValue: EnumValidationExample_MyEnum;
}

/** 列挙型の定義 */
export enum EnumValidationExample_MyEnum {
  /** MY_ENUM_UNSPECIFIED - 未指定（デフォルト） */
  MY_ENUM_UNSPECIFIED = 0,
  /** MY_ENUM_VALUE1 - 値1 */
  MY_ENUM_VALUE1 = 1,
  /** MY_ENUM_VALUE2 - 値2 */
  MY_ENUM_VALUE2 = 2,
  /** MY_ENUM_VALUE3 - 値3 */
  MY_ENUM_VALUE3 = 3,
  UNRECOGNIZED = -1,
}

export function enumValidationExample_MyEnumFromJSON(object: any): EnumValidationExample_MyEnum {
  switch (object) {
    case 0:
    case "MY_ENUM_UNSPECIFIED":
      return EnumValidationExample_MyEnum.MY_ENUM_UNSPECIFIED;
    case 1:
    case "MY_ENUM_VALUE1":
      return EnumValidationExample_MyEnum.MY_ENUM_VALUE1;
    case 2:
    case "MY_ENUM_VALUE2":
      return EnumValidationExample_MyEnum.MY_ENUM_VALUE2;
    case 3:
    case "MY_ENUM_VALUE3":
      return EnumValidationExample_MyEnum.MY_ENUM_VALUE3;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EnumValidationExample_MyEnum.UNRECOGNIZED;
  }
}

export function enumValidationExample_MyEnumToJSON(object: EnumValidationExample_MyEnum): string {
  switch (object) {
    case EnumValidationExample_MyEnum.MY_ENUM_UNSPECIFIED:
      return "MY_ENUM_UNSPECIFIED";
    case EnumValidationExample_MyEnum.MY_ENUM_VALUE1:
      return "MY_ENUM_VALUE1";
    case EnumValidationExample_MyEnum.MY_ENUM_VALUE2:
      return "MY_ENUM_VALUE2";
    case EnumValidationExample_MyEnum.MY_ENUM_VALUE3:
      return "MY_ENUM_VALUE3";
    case EnumValidationExample_MyEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Timestampの比較をしたいとき */
export interface TimestampValidationExample {
  /** 指定された時刻と一致している必要があるとき */
  constValue:
    | Date
    | undefined;
  /** 指定された時刻よりも前である必要があるとき */
  ltValue:
    | Date
    | undefined;
  /** 指定された時刻以前（同じでもOK）である必要があるとき */
  lteValue:
    | Date
    | undefined;
  /** 現在時刻よりも前である必要があるとき */
  ltNowValue:
    | Date
    | undefined;
  /** 指定された時刻よりも後である必要があるとき */
  gtValue:
    | Date
    | undefined;
  /** 指定された時刻以降（同じでもOK）である必要があるとき */
  gteValue:
    | Date
    | undefined;
  /** 現在時刻よりも後である必要があるとき */
  gtNowValue:
    | Date
    | undefined;
  /** 現在時刻の前後N秒以内である必要があるとき（この例では±1時間） */
  withinValue: Date | undefined;
}

export interface GoogleApiFieldExample {
  /** サーバーからの出力専用フィールド（リクエストに含めても無視される） */
  createdAt:
    | Date
    | undefined;
  /** クライアントからの入力専用フィールド（レスポンスには含まれない） */
  updatedAt:
    | Date
    | undefined;
  /** リクエスト時に必須のフィールド（未指定ならバリデーションエラー） */
  requiredAt:
    | Date
    | undefined;
  /** 明示的にオプション（省略可能）であることを示すフィールド */
  optionalAt: Date | undefined;
}

/** CEL式で柔軟なルールを定義したいとき */
export interface FieldConstraintsExample {
  /** 偶数であることを検証するCEL式 */
  evenValue: number;
}

function createBaseDeprecatedExample(): DeprecatedExample {
  return { deprecatedValue: "" };
}

export const DeprecatedExample: MessageFns<DeprecatedExample> = {
  encode(message: DeprecatedExample, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deprecatedValue !== "") {
      writer.uint32(10).string(message.deprecatedValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeprecatedExample {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeprecatedExample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deprecatedValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeprecatedExample {
    return { deprecatedValue: isSet(object.deprecatedValue) ? globalThis.String(object.deprecatedValue) : "" };
  },

  toJSON(message: DeprecatedExample): unknown {
    const obj: any = {};
    if (message.deprecatedValue !== "") {
      obj.deprecatedValue = message.deprecatedValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeprecatedExample>, I>>(base?: I): DeprecatedExample {
    return DeprecatedExample.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeprecatedExample>, I>>(object: I): DeprecatedExample {
    const message = createBaseDeprecatedExample();
    message.deprecatedValue = object.deprecatedValue ?? "";
    return message;
  },
};

function createBaseOneofExample(): OneofExample {
  return { val1: undefined, val2: undefined };
}

export const OneofExample: MessageFns<OneofExample> = {
  encode(message: OneofExample, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val1 !== undefined) {
      writer.uint32(10).string(message.val1);
    }
    if (message.val2 !== undefined) {
      writer.uint32(18).string(message.val2);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OneofExample {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOneofExample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.val1 = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.val2 = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OneofExample {
    return {
      val1: isSet(object.val1) ? globalThis.String(object.val1) : undefined,
      val2: isSet(object.val2) ? globalThis.String(object.val2) : undefined,
    };
  },

  toJSON(message: OneofExample): unknown {
    const obj: any = {};
    if (message.val1 !== undefined) {
      obj.val1 = message.val1;
    }
    if (message.val2 !== undefined) {
      obj.val2 = message.val2;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OneofExample>, I>>(base?: I): OneofExample {
    return OneofExample.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OneofExample>, I>>(object: I): OneofExample {
    const message = createBaseOneofExample();
    message.val1 = object.val1 ?? undefined;
    message.val2 = object.val2 ?? undefined;
    return message;
  },
};

function createBaseIgnoreEmptyExample(): IgnoreEmptyExample {
  return { val1: "", val2: "", val3: "" };
}

export const IgnoreEmptyExample: MessageFns<IgnoreEmptyExample> = {
  encode(message: IgnoreEmptyExample, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.val1 !== "") {
      writer.uint32(10).string(message.val1);
    }
    if (message.val2 !== "") {
      writer.uint32(18).string(message.val2);
    }
    if (message.val3 !== "") {
      writer.uint32(26).string(message.val3);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IgnoreEmptyExample {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIgnoreEmptyExample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.val1 = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.val2 = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.val3 = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IgnoreEmptyExample {
    return {
      val1: isSet(object.val1) ? globalThis.String(object.val1) : "",
      val2: isSet(object.val2) ? globalThis.String(object.val2) : "",
      val3: isSet(object.val3) ? globalThis.String(object.val3) : "",
    };
  },

  toJSON(message: IgnoreEmptyExample): unknown {
    const obj: any = {};
    if (message.val1 !== "") {
      obj.val1 = message.val1;
    }
    if (message.val2 !== "") {
      obj.val2 = message.val2;
    }
    if (message.val3 !== "") {
      obj.val3 = message.val3;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IgnoreEmptyExample>, I>>(base?: I): IgnoreEmptyExample {
    return IgnoreEmptyExample.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IgnoreEmptyExample>, I>>(object: I): IgnoreEmptyExample {
    const message = createBaseIgnoreEmptyExample();
    message.val1 = object.val1 ?? "";
    message.val2 = object.val2 ?? "";
    message.val3 = object.val3 ?? "";
    return message;
  },
};

function createBaseStringValidationExample(): StringValidationExample {
  return {
    constValue: "",
    lenValue: "",
    minLenValue: "",
    maxLenValue: "",
    lenBytesValue: "",
    minBytesValue: "",
    maxBytesValue: "",
    patternValue: "",
    prefixValue: "",
    suffixValue: "",
    containsValue: "",
    notContainsValue: "",
    inValue: "",
    notInValue: "",
    emailValue: "",
    hostnameValue: "",
    ipValue: "",
    ipv4Value: "",
    ipv6Value: "",
    uriValue: "",
    uriRefValue: "",
    addressValue: "",
    uuidValue: "",
    tuuidValue: "",
    ipWithPreifxlenValue: "",
    ipv4WithPreifxlenValue: "",
    ipv6WithPreifxlenValue: "",
    ipPrefixValue: "",
    ip4PrefixValue: "",
    ip6PrefixValue: "",
    hostAndPortValue: "",
    wellKownRegexValue: "",
  };
}

export const StringValidationExample: MessageFns<StringValidationExample> = {
  encode(message: StringValidationExample, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.constValue !== "") {
      writer.uint32(10).string(message.constValue);
    }
    if (message.lenValue !== "") {
      writer.uint32(18).string(message.lenValue);
    }
    if (message.minLenValue !== "") {
      writer.uint32(26).string(message.minLenValue);
    }
    if (message.maxLenValue !== "") {
      writer.uint32(34).string(message.maxLenValue);
    }
    if (message.lenBytesValue !== "") {
      writer.uint32(42).string(message.lenBytesValue);
    }
    if (message.minBytesValue !== "") {
      writer.uint32(50).string(message.minBytesValue);
    }
    if (message.maxBytesValue !== "") {
      writer.uint32(58).string(message.maxBytesValue);
    }
    if (message.patternValue !== "") {
      writer.uint32(66).string(message.patternValue);
    }
    if (message.prefixValue !== "") {
      writer.uint32(74).string(message.prefixValue);
    }
    if (message.suffixValue !== "") {
      writer.uint32(82).string(message.suffixValue);
    }
    if (message.containsValue !== "") {
      writer.uint32(90).string(message.containsValue);
    }
    if (message.notContainsValue !== "") {
      writer.uint32(98).string(message.notContainsValue);
    }
    if (message.inValue !== "") {
      writer.uint32(106).string(message.inValue);
    }
    if (message.notInValue !== "") {
      writer.uint32(114).string(message.notInValue);
    }
    if (message.emailValue !== "") {
      writer.uint32(122).string(message.emailValue);
    }
    if (message.hostnameValue !== "") {
      writer.uint32(130).string(message.hostnameValue);
    }
    if (message.ipValue !== "") {
      writer.uint32(138).string(message.ipValue);
    }
    if (message.ipv4Value !== "") {
      writer.uint32(146).string(message.ipv4Value);
    }
    if (message.ipv6Value !== "") {
      writer.uint32(154).string(message.ipv6Value);
    }
    if (message.uriValue !== "") {
      writer.uint32(162).string(message.uriValue);
    }
    if (message.uriRefValue !== "") {
      writer.uint32(170).string(message.uriRefValue);
    }
    if (message.addressValue !== "") {
      writer.uint32(178).string(message.addressValue);
    }
    if (message.uuidValue !== "") {
      writer.uint32(186).string(message.uuidValue);
    }
    if (message.tuuidValue !== "") {
      writer.uint32(194).string(message.tuuidValue);
    }
    if (message.ipWithPreifxlenValue !== "") {
      writer.uint32(202).string(message.ipWithPreifxlenValue);
    }
    if (message.ipv4WithPreifxlenValue !== "") {
      writer.uint32(210).string(message.ipv4WithPreifxlenValue);
    }
    if (message.ipv6WithPreifxlenValue !== "") {
      writer.uint32(218).string(message.ipv6WithPreifxlenValue);
    }
    if (message.ipPrefixValue !== "") {
      writer.uint32(226).string(message.ipPrefixValue);
    }
    if (message.ip4PrefixValue !== "") {
      writer.uint32(234).string(message.ip4PrefixValue);
    }
    if (message.ip6PrefixValue !== "") {
      writer.uint32(242).string(message.ip6PrefixValue);
    }
    if (message.hostAndPortValue !== "") {
      writer.uint32(250).string(message.hostAndPortValue);
    }
    if (message.wellKownRegexValue !== "") {
      writer.uint32(258).string(message.wellKownRegexValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringValidationExample {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringValidationExample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.constValue = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lenValue = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.minLenValue = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.maxLenValue = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lenBytesValue = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.minBytesValue = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.maxBytesValue = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.patternValue = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.prefixValue = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.suffixValue = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.containsValue = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.notContainsValue = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.inValue = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.notInValue = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.emailValue = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.hostnameValue = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.ipValue = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.ipv4Value = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.ipv6Value = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.uriValue = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.uriRefValue = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.addressValue = reader.string();
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.uuidValue = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.tuuidValue = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.ipWithPreifxlenValue = reader.string();
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.ipv4WithPreifxlenValue = reader.string();
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.ipv6WithPreifxlenValue = reader.string();
          continue;
        }
        case 28: {
          if (tag !== 226) {
            break;
          }

          message.ipPrefixValue = reader.string();
          continue;
        }
        case 29: {
          if (tag !== 234) {
            break;
          }

          message.ip4PrefixValue = reader.string();
          continue;
        }
        case 30: {
          if (tag !== 242) {
            break;
          }

          message.ip6PrefixValue = reader.string();
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.hostAndPortValue = reader.string();
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.wellKownRegexValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringValidationExample {
    return {
      constValue: isSet(object.constValue) ? globalThis.String(object.constValue) : "",
      lenValue: isSet(object.lenValue) ? globalThis.String(object.lenValue) : "",
      minLenValue: isSet(object.minLenValue) ? globalThis.String(object.minLenValue) : "",
      maxLenValue: isSet(object.maxLenValue) ? globalThis.String(object.maxLenValue) : "",
      lenBytesValue: isSet(object.lenBytesValue) ? globalThis.String(object.lenBytesValue) : "",
      minBytesValue: isSet(object.minBytesValue) ? globalThis.String(object.minBytesValue) : "",
      maxBytesValue: isSet(object.maxBytesValue) ? globalThis.String(object.maxBytesValue) : "",
      patternValue: isSet(object.patternValue) ? globalThis.String(object.patternValue) : "",
      prefixValue: isSet(object.prefixValue) ? globalThis.String(object.prefixValue) : "",
      suffixValue: isSet(object.suffixValue) ? globalThis.String(object.suffixValue) : "",
      containsValue: isSet(object.containsValue) ? globalThis.String(object.containsValue) : "",
      notContainsValue: isSet(object.notContainsValue) ? globalThis.String(object.notContainsValue) : "",
      inValue: isSet(object.inValue) ? globalThis.String(object.inValue) : "",
      notInValue: isSet(object.notInValue) ? globalThis.String(object.notInValue) : "",
      emailValue: isSet(object.emailValue) ? globalThis.String(object.emailValue) : "",
      hostnameValue: isSet(object.hostnameValue) ? globalThis.String(object.hostnameValue) : "",
      ipValue: isSet(object.ipValue) ? globalThis.String(object.ipValue) : "",
      ipv4Value: isSet(object.ipv4Value) ? globalThis.String(object.ipv4Value) : "",
      ipv6Value: isSet(object.ipv6Value) ? globalThis.String(object.ipv6Value) : "",
      uriValue: isSet(object.uriValue) ? globalThis.String(object.uriValue) : "",
      uriRefValue: isSet(object.uriRefValue) ? globalThis.String(object.uriRefValue) : "",
      addressValue: isSet(object.addressValue) ? globalThis.String(object.addressValue) : "",
      uuidValue: isSet(object.uuidValue) ? globalThis.String(object.uuidValue) : "",
      tuuidValue: isSet(object.tuuidValue) ? globalThis.String(object.tuuidValue) : "",
      ipWithPreifxlenValue: isSet(object.ipWithPreifxlenValue) ? globalThis.String(object.ipWithPreifxlenValue) : "",
      ipv4WithPreifxlenValue: isSet(object.ipv4WithPreifxlenValue)
        ? globalThis.String(object.ipv4WithPreifxlenValue)
        : "",
      ipv6WithPreifxlenValue: isSet(object.ipv6WithPreifxlenValue)
        ? globalThis.String(object.ipv6WithPreifxlenValue)
        : "",
      ipPrefixValue: isSet(object.ipPrefixValue) ? globalThis.String(object.ipPrefixValue) : "",
      ip4PrefixValue: isSet(object.ip4PrefixValue) ? globalThis.String(object.ip4PrefixValue) : "",
      ip6PrefixValue: isSet(object.ip6PrefixValue) ? globalThis.String(object.ip6PrefixValue) : "",
      hostAndPortValue: isSet(object.hostAndPortValue) ? globalThis.String(object.hostAndPortValue) : "",
      wellKownRegexValue: isSet(object.wellKownRegexValue) ? globalThis.String(object.wellKownRegexValue) : "",
    };
  },

  toJSON(message: StringValidationExample): unknown {
    const obj: any = {};
    if (message.constValue !== "") {
      obj.constValue = message.constValue;
    }
    if (message.lenValue !== "") {
      obj.lenValue = message.lenValue;
    }
    if (message.minLenValue !== "") {
      obj.minLenValue = message.minLenValue;
    }
    if (message.maxLenValue !== "") {
      obj.maxLenValue = message.maxLenValue;
    }
    if (message.lenBytesValue !== "") {
      obj.lenBytesValue = message.lenBytesValue;
    }
    if (message.minBytesValue !== "") {
      obj.minBytesValue = message.minBytesValue;
    }
    if (message.maxBytesValue !== "") {
      obj.maxBytesValue = message.maxBytesValue;
    }
    if (message.patternValue !== "") {
      obj.patternValue = message.patternValue;
    }
    if (message.prefixValue !== "") {
      obj.prefixValue = message.prefixValue;
    }
    if (message.suffixValue !== "") {
      obj.suffixValue = message.suffixValue;
    }
    if (message.containsValue !== "") {
      obj.containsValue = message.containsValue;
    }
    if (message.notContainsValue !== "") {
      obj.notContainsValue = message.notContainsValue;
    }
    if (message.inValue !== "") {
      obj.inValue = message.inValue;
    }
    if (message.notInValue !== "") {
      obj.notInValue = message.notInValue;
    }
    if (message.emailValue !== "") {
      obj.emailValue = message.emailValue;
    }
    if (message.hostnameValue !== "") {
      obj.hostnameValue = message.hostnameValue;
    }
    if (message.ipValue !== "") {
      obj.ipValue = message.ipValue;
    }
    if (message.ipv4Value !== "") {
      obj.ipv4Value = message.ipv4Value;
    }
    if (message.ipv6Value !== "") {
      obj.ipv6Value = message.ipv6Value;
    }
    if (message.uriValue !== "") {
      obj.uriValue = message.uriValue;
    }
    if (message.uriRefValue !== "") {
      obj.uriRefValue = message.uriRefValue;
    }
    if (message.addressValue !== "") {
      obj.addressValue = message.addressValue;
    }
    if (message.uuidValue !== "") {
      obj.uuidValue = message.uuidValue;
    }
    if (message.tuuidValue !== "") {
      obj.tuuidValue = message.tuuidValue;
    }
    if (message.ipWithPreifxlenValue !== "") {
      obj.ipWithPreifxlenValue = message.ipWithPreifxlenValue;
    }
    if (message.ipv4WithPreifxlenValue !== "") {
      obj.ipv4WithPreifxlenValue = message.ipv4WithPreifxlenValue;
    }
    if (message.ipv6WithPreifxlenValue !== "") {
      obj.ipv6WithPreifxlenValue = message.ipv6WithPreifxlenValue;
    }
    if (message.ipPrefixValue !== "") {
      obj.ipPrefixValue = message.ipPrefixValue;
    }
    if (message.ip4PrefixValue !== "") {
      obj.ip4PrefixValue = message.ip4PrefixValue;
    }
    if (message.ip6PrefixValue !== "") {
      obj.ip6PrefixValue = message.ip6PrefixValue;
    }
    if (message.hostAndPortValue !== "") {
      obj.hostAndPortValue = message.hostAndPortValue;
    }
    if (message.wellKownRegexValue !== "") {
      obj.wellKownRegexValue = message.wellKownRegexValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StringValidationExample>, I>>(base?: I): StringValidationExample {
    return StringValidationExample.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StringValidationExample>, I>>(object: I): StringValidationExample {
    const message = createBaseStringValidationExample();
    message.constValue = object.constValue ?? "";
    message.lenValue = object.lenValue ?? "";
    message.minLenValue = object.minLenValue ?? "";
    message.maxLenValue = object.maxLenValue ?? "";
    message.lenBytesValue = object.lenBytesValue ?? "";
    message.minBytesValue = object.minBytesValue ?? "";
    message.maxBytesValue = object.maxBytesValue ?? "";
    message.patternValue = object.patternValue ?? "";
    message.prefixValue = object.prefixValue ?? "";
    message.suffixValue = object.suffixValue ?? "";
    message.containsValue = object.containsValue ?? "";
    message.notContainsValue = object.notContainsValue ?? "";
    message.inValue = object.inValue ?? "";
    message.notInValue = object.notInValue ?? "";
    message.emailValue = object.emailValue ?? "";
    message.hostnameValue = object.hostnameValue ?? "";
    message.ipValue = object.ipValue ?? "";
    message.ipv4Value = object.ipv4Value ?? "";
    message.ipv6Value = object.ipv6Value ?? "";
    message.uriValue = object.uriValue ?? "";
    message.uriRefValue = object.uriRefValue ?? "";
    message.addressValue = object.addressValue ?? "";
    message.uuidValue = object.uuidValue ?? "";
    message.tuuidValue = object.tuuidValue ?? "";
    message.ipWithPreifxlenValue = object.ipWithPreifxlenValue ?? "";
    message.ipv4WithPreifxlenValue = object.ipv4WithPreifxlenValue ?? "";
    message.ipv6WithPreifxlenValue = object.ipv6WithPreifxlenValue ?? "";
    message.ipPrefixValue = object.ipPrefixValue ?? "";
    message.ip4PrefixValue = object.ip4PrefixValue ?? "";
    message.ip6PrefixValue = object.ip6PrefixValue ?? "";
    message.hostAndPortValue = object.hostAndPortValue ?? "";
    message.wellKownRegexValue = object.wellKownRegexValue ?? "";
    return message;
  },
};

function createBaseBoolValidationExample(): BoolValidationExample {
  return { trueValue: false, falseValue: false };
}

export const BoolValidationExample: MessageFns<BoolValidationExample> = {
  encode(message: BoolValidationExample, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trueValue !== false) {
      writer.uint32(8).bool(message.trueValue);
    }
    if (message.falseValue !== false) {
      writer.uint32(16).bool(message.falseValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BoolValidationExample {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBoolValidationExample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.trueValue = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.falseValue = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BoolValidationExample {
    return {
      trueValue: isSet(object.trueValue) ? globalThis.Boolean(object.trueValue) : false,
      falseValue: isSet(object.falseValue) ? globalThis.Boolean(object.falseValue) : false,
    };
  },

  toJSON(message: BoolValidationExample): unknown {
    const obj: any = {};
    if (message.trueValue !== false) {
      obj.trueValue = message.trueValue;
    }
    if (message.falseValue !== false) {
      obj.falseValue = message.falseValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BoolValidationExample>, I>>(base?: I): BoolValidationExample {
    return BoolValidationExample.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BoolValidationExample>, I>>(object: I): BoolValidationExample {
    const message = createBaseBoolValidationExample();
    message.trueValue = object.trueValue ?? false;
    message.falseValue = object.falseValue ?? false;
    return message;
  },
};

function createBaseBytesValidationExample(): BytesValidationExample {
  return {
    constValue: new Uint8Array(0),
    lenValue: new Uint8Array(0),
    minLenValue: new Uint8Array(0),
    maxLenValue: new Uint8Array(0),
    patternValue: new Uint8Array(0),
    prefixValue: new Uint8Array(0),
    suffixValue: new Uint8Array(0),
    containsValue: new Uint8Array(0),
    inValue: new Uint8Array(0),
    notInValue: new Uint8Array(0),
    ipValue: new Uint8Array(0),
    ipv4Value: new Uint8Array(0),
    ipv6Value: new Uint8Array(0),
  };
}

export const BytesValidationExample: MessageFns<BytesValidationExample> = {
  encode(message: BytesValidationExample, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.constValue.length !== 0) {
      writer.uint32(10).bytes(message.constValue);
    }
    if (message.lenValue.length !== 0) {
      writer.uint32(18).bytes(message.lenValue);
    }
    if (message.minLenValue.length !== 0) {
      writer.uint32(26).bytes(message.minLenValue);
    }
    if (message.maxLenValue.length !== 0) {
      writer.uint32(34).bytes(message.maxLenValue);
    }
    if (message.patternValue.length !== 0) {
      writer.uint32(42).bytes(message.patternValue);
    }
    if (message.prefixValue.length !== 0) {
      writer.uint32(50).bytes(message.prefixValue);
    }
    if (message.suffixValue.length !== 0) {
      writer.uint32(58).bytes(message.suffixValue);
    }
    if (message.containsValue.length !== 0) {
      writer.uint32(66).bytes(message.containsValue);
    }
    if (message.inValue.length !== 0) {
      writer.uint32(74).bytes(message.inValue);
    }
    if (message.notInValue.length !== 0) {
      writer.uint32(82).bytes(message.notInValue);
    }
    if (message.ipValue.length !== 0) {
      writer.uint32(90).bytes(message.ipValue);
    }
    if (message.ipv4Value.length !== 0) {
      writer.uint32(98).bytes(message.ipv4Value);
    }
    if (message.ipv6Value.length !== 0) {
      writer.uint32(106).bytes(message.ipv6Value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BytesValidationExample {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBytesValidationExample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.constValue = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lenValue = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.minLenValue = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.maxLenValue = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.patternValue = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.prefixValue = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.suffixValue = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.containsValue = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.inValue = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.notInValue = reader.bytes();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.ipValue = reader.bytes();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.ipv4Value = reader.bytes();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.ipv6Value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BytesValidationExample {
    return {
      constValue: isSet(object.constValue) ? bytesFromBase64(object.constValue) : new Uint8Array(0),
      lenValue: isSet(object.lenValue) ? bytesFromBase64(object.lenValue) : new Uint8Array(0),
      minLenValue: isSet(object.minLenValue) ? bytesFromBase64(object.minLenValue) : new Uint8Array(0),
      maxLenValue: isSet(object.maxLenValue) ? bytesFromBase64(object.maxLenValue) : new Uint8Array(0),
      patternValue: isSet(object.patternValue) ? bytesFromBase64(object.patternValue) : new Uint8Array(0),
      prefixValue: isSet(object.prefixValue) ? bytesFromBase64(object.prefixValue) : new Uint8Array(0),
      suffixValue: isSet(object.suffixValue) ? bytesFromBase64(object.suffixValue) : new Uint8Array(0),
      containsValue: isSet(object.containsValue) ? bytesFromBase64(object.containsValue) : new Uint8Array(0),
      inValue: isSet(object.inValue) ? bytesFromBase64(object.inValue) : new Uint8Array(0),
      notInValue: isSet(object.notInValue) ? bytesFromBase64(object.notInValue) : new Uint8Array(0),
      ipValue: isSet(object.ipValue) ? bytesFromBase64(object.ipValue) : new Uint8Array(0),
      ipv4Value: isSet(object.ipv4Value) ? bytesFromBase64(object.ipv4Value) : new Uint8Array(0),
      ipv6Value: isSet(object.ipv6Value) ? bytesFromBase64(object.ipv6Value) : new Uint8Array(0),
    };
  },

  toJSON(message: BytesValidationExample): unknown {
    const obj: any = {};
    if (message.constValue.length !== 0) {
      obj.constValue = base64FromBytes(message.constValue);
    }
    if (message.lenValue.length !== 0) {
      obj.lenValue = base64FromBytes(message.lenValue);
    }
    if (message.minLenValue.length !== 0) {
      obj.minLenValue = base64FromBytes(message.minLenValue);
    }
    if (message.maxLenValue.length !== 0) {
      obj.maxLenValue = base64FromBytes(message.maxLenValue);
    }
    if (message.patternValue.length !== 0) {
      obj.patternValue = base64FromBytes(message.patternValue);
    }
    if (message.prefixValue.length !== 0) {
      obj.prefixValue = base64FromBytes(message.prefixValue);
    }
    if (message.suffixValue.length !== 0) {
      obj.suffixValue = base64FromBytes(message.suffixValue);
    }
    if (message.containsValue.length !== 0) {
      obj.containsValue = base64FromBytes(message.containsValue);
    }
    if (message.inValue.length !== 0) {
      obj.inValue = base64FromBytes(message.inValue);
    }
    if (message.notInValue.length !== 0) {
      obj.notInValue = base64FromBytes(message.notInValue);
    }
    if (message.ipValue.length !== 0) {
      obj.ipValue = base64FromBytes(message.ipValue);
    }
    if (message.ipv4Value.length !== 0) {
      obj.ipv4Value = base64FromBytes(message.ipv4Value);
    }
    if (message.ipv6Value.length !== 0) {
      obj.ipv6Value = base64FromBytes(message.ipv6Value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BytesValidationExample>, I>>(base?: I): BytesValidationExample {
    return BytesValidationExample.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BytesValidationExample>, I>>(object: I): BytesValidationExample {
    const message = createBaseBytesValidationExample();
    message.constValue = object.constValue ?? new Uint8Array(0);
    message.lenValue = object.lenValue ?? new Uint8Array(0);
    message.minLenValue = object.minLenValue ?? new Uint8Array(0);
    message.maxLenValue = object.maxLenValue ?? new Uint8Array(0);
    message.patternValue = object.patternValue ?? new Uint8Array(0);
    message.prefixValue = object.prefixValue ?? new Uint8Array(0);
    message.suffixValue = object.suffixValue ?? new Uint8Array(0);
    message.containsValue = object.containsValue ?? new Uint8Array(0);
    message.inValue = object.inValue ?? new Uint8Array(0);
    message.notInValue = object.notInValue ?? new Uint8Array(0);
    message.ipValue = object.ipValue ?? new Uint8Array(0);
    message.ipv4Value = object.ipv4Value ?? new Uint8Array(0);
    message.ipv6Value = object.ipv6Value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseDoubleValidationExample(): DoubleValidationExample {
  return { constValue: 0, ltValue: 0, lteValue: 0, gtValue: 0, gteValue: 0, inValue: 0, notInValue: 0, finiteValue: 0 };
}

export const DoubleValidationExample: MessageFns<DoubleValidationExample> = {
  encode(message: DoubleValidationExample, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.constValue !== 0) {
      writer.uint32(9).double(message.constValue);
    }
    if (message.ltValue !== 0) {
      writer.uint32(17).double(message.ltValue);
    }
    if (message.lteValue !== 0) {
      writer.uint32(25).double(message.lteValue);
    }
    if (message.gtValue !== 0) {
      writer.uint32(33).double(message.gtValue);
    }
    if (message.gteValue !== 0) {
      writer.uint32(41).double(message.gteValue);
    }
    if (message.inValue !== 0) {
      writer.uint32(49).double(message.inValue);
    }
    if (message.notInValue !== 0) {
      writer.uint32(57).double(message.notInValue);
    }
    if (message.finiteValue !== 0) {
      writer.uint32(65).double(message.finiteValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DoubleValidationExample {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDoubleValidationExample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.constValue = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.ltValue = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.lteValue = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.gtValue = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.gteValue = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.inValue = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.notInValue = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 65) {
            break;
          }

          message.finiteValue = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DoubleValidationExample {
    return {
      constValue: isSet(object.constValue) ? globalThis.Number(object.constValue) : 0,
      ltValue: isSet(object.ltValue) ? globalThis.Number(object.ltValue) : 0,
      lteValue: isSet(object.lteValue) ? globalThis.Number(object.lteValue) : 0,
      gtValue: isSet(object.gtValue) ? globalThis.Number(object.gtValue) : 0,
      gteValue: isSet(object.gteValue) ? globalThis.Number(object.gteValue) : 0,
      inValue: isSet(object.inValue) ? globalThis.Number(object.inValue) : 0,
      notInValue: isSet(object.notInValue) ? globalThis.Number(object.notInValue) : 0,
      finiteValue: isSet(object.finiteValue) ? globalThis.Number(object.finiteValue) : 0,
    };
  },

  toJSON(message: DoubleValidationExample): unknown {
    const obj: any = {};
    if (message.constValue !== 0) {
      obj.constValue = message.constValue;
    }
    if (message.ltValue !== 0) {
      obj.ltValue = message.ltValue;
    }
    if (message.lteValue !== 0) {
      obj.lteValue = message.lteValue;
    }
    if (message.gtValue !== 0) {
      obj.gtValue = message.gtValue;
    }
    if (message.gteValue !== 0) {
      obj.gteValue = message.gteValue;
    }
    if (message.inValue !== 0) {
      obj.inValue = message.inValue;
    }
    if (message.notInValue !== 0) {
      obj.notInValue = message.notInValue;
    }
    if (message.finiteValue !== 0) {
      obj.finiteValue = message.finiteValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DoubleValidationExample>, I>>(base?: I): DoubleValidationExample {
    return DoubleValidationExample.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DoubleValidationExample>, I>>(object: I): DoubleValidationExample {
    const message = createBaseDoubleValidationExample();
    message.constValue = object.constValue ?? 0;
    message.ltValue = object.ltValue ?? 0;
    message.lteValue = object.lteValue ?? 0;
    message.gtValue = object.gtValue ?? 0;
    message.gteValue = object.gteValue ?? 0;
    message.inValue = object.inValue ?? 0;
    message.notInValue = object.notInValue ?? 0;
    message.finiteValue = object.finiteValue ?? 0;
    return message;
  },
};

function createBaseMapValidationExample(): MapValidationExample {
  return { minPairsValue: {}, maxPairsValue: {}, keysValue: {}, valuesValue: {} };
}

export const MapValidationExample: MessageFns<MapValidationExample> = {
  encode(message: MapValidationExample, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.minPairsValue).forEach(([key, value]) => {
      MapValidationExample_MinPairsValueEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    Object.entries(message.maxPairsValue).forEach(([key, value]) => {
      MapValidationExample_MaxPairsValueEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    Object.entries(message.keysValue).forEach(([key, value]) => {
      MapValidationExample_KeysValueEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    Object.entries(message.valuesValue).forEach(([key, value]) => {
      MapValidationExample_ValuesValueEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapValidationExample {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapValidationExample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = MapValidationExample_MinPairsValueEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.minPairsValue[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = MapValidationExample_MaxPairsValueEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.maxPairsValue[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = MapValidationExample_KeysValueEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.keysValue[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = MapValidationExample_ValuesValueEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.valuesValue[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapValidationExample {
    return {
      minPairsValue: isObject(object.minPairsValue)
        ? Object.entries(object.minPairsValue).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      maxPairsValue: isObject(object.maxPairsValue)
        ? Object.entries(object.maxPairsValue).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      keysValue: isObject(object.keysValue)
        ? Object.entries(object.keysValue).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      valuesValue: isObject(object.valuesValue)
        ? Object.entries(object.valuesValue).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MapValidationExample): unknown {
    const obj: any = {};
    if (message.minPairsValue) {
      const entries = Object.entries(message.minPairsValue);
      if (entries.length > 0) {
        obj.minPairsValue = {};
        entries.forEach(([k, v]) => {
          obj.minPairsValue[k] = v;
        });
      }
    }
    if (message.maxPairsValue) {
      const entries = Object.entries(message.maxPairsValue);
      if (entries.length > 0) {
        obj.maxPairsValue = {};
        entries.forEach(([k, v]) => {
          obj.maxPairsValue[k] = v;
        });
      }
    }
    if (message.keysValue) {
      const entries = Object.entries(message.keysValue);
      if (entries.length > 0) {
        obj.keysValue = {};
        entries.forEach(([k, v]) => {
          obj.keysValue[k] = v;
        });
      }
    }
    if (message.valuesValue) {
      const entries = Object.entries(message.valuesValue);
      if (entries.length > 0) {
        obj.valuesValue = {};
        entries.forEach(([k, v]) => {
          obj.valuesValue[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MapValidationExample>, I>>(base?: I): MapValidationExample {
    return MapValidationExample.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MapValidationExample>, I>>(object: I): MapValidationExample {
    const message = createBaseMapValidationExample();
    message.minPairsValue = Object.entries(object.minPairsValue ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.maxPairsValue = Object.entries(object.maxPairsValue ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.keysValue = Object.entries(object.keysValue ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.valuesValue = Object.entries(object.valuesValue ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseMapValidationExample_MinPairsValueEntry(): MapValidationExample_MinPairsValueEntry {
  return { key: "", value: "" };
}

export const MapValidationExample_MinPairsValueEntry: MessageFns<MapValidationExample_MinPairsValueEntry> = {
  encode(message: MapValidationExample_MinPairsValueEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapValidationExample_MinPairsValueEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapValidationExample_MinPairsValueEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapValidationExample_MinPairsValueEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MapValidationExample_MinPairsValueEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MapValidationExample_MinPairsValueEntry>, I>>(
    base?: I,
  ): MapValidationExample_MinPairsValueEntry {
    return MapValidationExample_MinPairsValueEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MapValidationExample_MinPairsValueEntry>, I>>(
    object: I,
  ): MapValidationExample_MinPairsValueEntry {
    const message = createBaseMapValidationExample_MinPairsValueEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMapValidationExample_MaxPairsValueEntry(): MapValidationExample_MaxPairsValueEntry {
  return { key: "", value: "" };
}

export const MapValidationExample_MaxPairsValueEntry: MessageFns<MapValidationExample_MaxPairsValueEntry> = {
  encode(message: MapValidationExample_MaxPairsValueEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapValidationExample_MaxPairsValueEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapValidationExample_MaxPairsValueEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapValidationExample_MaxPairsValueEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MapValidationExample_MaxPairsValueEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MapValidationExample_MaxPairsValueEntry>, I>>(
    base?: I,
  ): MapValidationExample_MaxPairsValueEntry {
    return MapValidationExample_MaxPairsValueEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MapValidationExample_MaxPairsValueEntry>, I>>(
    object: I,
  ): MapValidationExample_MaxPairsValueEntry {
    const message = createBaseMapValidationExample_MaxPairsValueEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMapValidationExample_KeysValueEntry(): MapValidationExample_KeysValueEntry {
  return { key: "", value: "" };
}

export const MapValidationExample_KeysValueEntry: MessageFns<MapValidationExample_KeysValueEntry> = {
  encode(message: MapValidationExample_KeysValueEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapValidationExample_KeysValueEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapValidationExample_KeysValueEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapValidationExample_KeysValueEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MapValidationExample_KeysValueEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MapValidationExample_KeysValueEntry>, I>>(
    base?: I,
  ): MapValidationExample_KeysValueEntry {
    return MapValidationExample_KeysValueEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MapValidationExample_KeysValueEntry>, I>>(
    object: I,
  ): MapValidationExample_KeysValueEntry {
    const message = createBaseMapValidationExample_KeysValueEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMapValidationExample_ValuesValueEntry(): MapValidationExample_ValuesValueEntry {
  return { key: "", value: "" };
}

export const MapValidationExample_ValuesValueEntry: MessageFns<MapValidationExample_ValuesValueEntry> = {
  encode(message: MapValidationExample_ValuesValueEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MapValidationExample_ValuesValueEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMapValidationExample_ValuesValueEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MapValidationExample_ValuesValueEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MapValidationExample_ValuesValueEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MapValidationExample_ValuesValueEntry>, I>>(
    base?: I,
  ): MapValidationExample_ValuesValueEntry {
    return MapValidationExample_ValuesValueEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MapValidationExample_ValuesValueEntry>, I>>(
    object: I,
  ): MapValidationExample_ValuesValueEntry {
    const message = createBaseMapValidationExample_ValuesValueEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRepeatedValidationExample(): RepeatedValidationExample {
  return { minItemsValue: [], maxItemsValue: [], uniqueValue: [], itemsValue: [] };
}

export const RepeatedValidationExample: MessageFns<RepeatedValidationExample> = {
  encode(message: RepeatedValidationExample, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.minItemsValue) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.maxItemsValue) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.uniqueValue) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.itemsValue) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RepeatedValidationExample {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRepeatedValidationExample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.minItemsValue.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.maxItemsValue.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.uniqueValue.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.itemsValue.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RepeatedValidationExample {
    return {
      minItemsValue: globalThis.Array.isArray(object?.minItemsValue)
        ? object.minItemsValue.map((e: any) => globalThis.String(e))
        : [],
      maxItemsValue: globalThis.Array.isArray(object?.maxItemsValue)
        ? object.maxItemsValue.map((e: any) => globalThis.String(e))
        : [],
      uniqueValue: globalThis.Array.isArray(object?.uniqueValue)
        ? object.uniqueValue.map((e: any) => globalThis.String(e))
        : [],
      itemsValue: globalThis.Array.isArray(object?.itemsValue)
        ? object.itemsValue.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: RepeatedValidationExample): unknown {
    const obj: any = {};
    if (message.minItemsValue?.length) {
      obj.minItemsValue = message.minItemsValue;
    }
    if (message.maxItemsValue?.length) {
      obj.maxItemsValue = message.maxItemsValue;
    }
    if (message.uniqueValue?.length) {
      obj.uniqueValue = message.uniqueValue;
    }
    if (message.itemsValue?.length) {
      obj.itemsValue = message.itemsValue;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RepeatedValidationExample>, I>>(base?: I): RepeatedValidationExample {
    return RepeatedValidationExample.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RepeatedValidationExample>, I>>(object: I): RepeatedValidationExample {
    const message = createBaseRepeatedValidationExample();
    message.minItemsValue = object.minItemsValue?.map((e) => e) || [];
    message.maxItemsValue = object.maxItemsValue?.map((e) => e) || [];
    message.uniqueValue = object.uniqueValue?.map((e) => e) || [];
    message.itemsValue = object.itemsValue?.map((e) => e) || [];
    return message;
  },
};

function createBaseAnyValidationExample(): AnyValidationExample {
  return { inValue: undefined, notInValue: undefined };
}

export const AnyValidationExample: MessageFns<AnyValidationExample> = {
  encode(message: AnyValidationExample, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.inValue !== undefined) {
      Any.encode(message.inValue, writer.uint32(10).fork()).join();
    }
    if (message.notInValue !== undefined) {
      Any.encode(message.notInValue, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnyValidationExample {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnyValidationExample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inValue = Any.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.notInValue = Any.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnyValidationExample {
    return {
      inValue: isSet(object.inValue) ? Any.fromJSON(object.inValue) : undefined,
      notInValue: isSet(object.notInValue) ? Any.fromJSON(object.notInValue) : undefined,
    };
  },

  toJSON(message: AnyValidationExample): unknown {
    const obj: any = {};
    if (message.inValue !== undefined) {
      obj.inValue = Any.toJSON(message.inValue);
    }
    if (message.notInValue !== undefined) {
      obj.notInValue = Any.toJSON(message.notInValue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnyValidationExample>, I>>(base?: I): AnyValidationExample {
    return AnyValidationExample.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnyValidationExample>, I>>(object: I): AnyValidationExample {
    const message = createBaseAnyValidationExample();
    message.inValue = (object.inValue !== undefined && object.inValue !== null)
      ? Any.fromPartial(object.inValue)
      : undefined;
    message.notInValue = (object.notInValue !== undefined && object.notInValue !== null)
      ? Any.fromPartial(object.notInValue)
      : undefined;
    return message;
  },
};

function createBaseDurationValidationExample(): DurationValidationExample {
  return {
    constValue: undefined,
    ltValue: undefined,
    lteValue: undefined,
    gtValue: undefined,
    gteValue: undefined,
    inValue: undefined,
    notInValue: undefined,
  };
}

export const DurationValidationExample: MessageFns<DurationValidationExample> = {
  encode(message: DurationValidationExample, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.constValue !== undefined) {
      Duration.encode(message.constValue, writer.uint32(10).fork()).join();
    }
    if (message.ltValue !== undefined) {
      Duration.encode(message.ltValue, writer.uint32(18).fork()).join();
    }
    if (message.lteValue !== undefined) {
      Duration.encode(message.lteValue, writer.uint32(26).fork()).join();
    }
    if (message.gtValue !== undefined) {
      Duration.encode(message.gtValue, writer.uint32(34).fork()).join();
    }
    if (message.gteValue !== undefined) {
      Duration.encode(message.gteValue, writer.uint32(42).fork()).join();
    }
    if (message.inValue !== undefined) {
      Duration.encode(message.inValue, writer.uint32(50).fork()).join();
    }
    if (message.notInValue !== undefined) {
      Duration.encode(message.notInValue, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DurationValidationExample {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDurationValidationExample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.constValue = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ltValue = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lteValue = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.gtValue = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.gteValue = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.inValue = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.notInValue = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DurationValidationExample {
    return {
      constValue: isSet(object.constValue) ? Duration.fromJSON(object.constValue) : undefined,
      ltValue: isSet(object.ltValue) ? Duration.fromJSON(object.ltValue) : undefined,
      lteValue: isSet(object.lteValue) ? Duration.fromJSON(object.lteValue) : undefined,
      gtValue: isSet(object.gtValue) ? Duration.fromJSON(object.gtValue) : undefined,
      gteValue: isSet(object.gteValue) ? Duration.fromJSON(object.gteValue) : undefined,
      inValue: isSet(object.inValue) ? Duration.fromJSON(object.inValue) : undefined,
      notInValue: isSet(object.notInValue) ? Duration.fromJSON(object.notInValue) : undefined,
    };
  },

  toJSON(message: DurationValidationExample): unknown {
    const obj: any = {};
    if (message.constValue !== undefined) {
      obj.constValue = Duration.toJSON(message.constValue);
    }
    if (message.ltValue !== undefined) {
      obj.ltValue = Duration.toJSON(message.ltValue);
    }
    if (message.lteValue !== undefined) {
      obj.lteValue = Duration.toJSON(message.lteValue);
    }
    if (message.gtValue !== undefined) {
      obj.gtValue = Duration.toJSON(message.gtValue);
    }
    if (message.gteValue !== undefined) {
      obj.gteValue = Duration.toJSON(message.gteValue);
    }
    if (message.inValue !== undefined) {
      obj.inValue = Duration.toJSON(message.inValue);
    }
    if (message.notInValue !== undefined) {
      obj.notInValue = Duration.toJSON(message.notInValue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DurationValidationExample>, I>>(base?: I): DurationValidationExample {
    return DurationValidationExample.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DurationValidationExample>, I>>(object: I): DurationValidationExample {
    const message = createBaseDurationValidationExample();
    message.constValue = (object.constValue !== undefined && object.constValue !== null)
      ? Duration.fromPartial(object.constValue)
      : undefined;
    message.ltValue = (object.ltValue !== undefined && object.ltValue !== null)
      ? Duration.fromPartial(object.ltValue)
      : undefined;
    message.lteValue = (object.lteValue !== undefined && object.lteValue !== null)
      ? Duration.fromPartial(object.lteValue)
      : undefined;
    message.gtValue = (object.gtValue !== undefined && object.gtValue !== null)
      ? Duration.fromPartial(object.gtValue)
      : undefined;
    message.gteValue = (object.gteValue !== undefined && object.gteValue !== null)
      ? Duration.fromPartial(object.gteValue)
      : undefined;
    message.inValue = (object.inValue !== undefined && object.inValue !== null)
      ? Duration.fromPartial(object.inValue)
      : undefined;
    message.notInValue = (object.notInValue !== undefined && object.notInValue !== null)
      ? Duration.fromPartial(object.notInValue)
      : undefined;
    return message;
  },
};

function createBaseEnumValidationExample(): EnumValidationExample {
  return { constValue: 0, definedOnlyValue: 0, inValue: 0, notInValue: 0 };
}

export const EnumValidationExample: MessageFns<EnumValidationExample> = {
  encode(message: EnumValidationExample, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.constValue !== 0) {
      writer.uint32(8).int32(message.constValue);
    }
    if (message.definedOnlyValue !== 0) {
      writer.uint32(16).int32(message.definedOnlyValue);
    }
    if (message.inValue !== 0) {
      writer.uint32(24).int32(message.inValue);
    }
    if (message.notInValue !== 0) {
      writer.uint32(32).int32(message.notInValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnumValidationExample {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnumValidationExample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.constValue = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.definedOnlyValue = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.inValue = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.notInValue = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnumValidationExample {
    return {
      constValue: isSet(object.constValue) ? enumValidationExample_MyEnumFromJSON(object.constValue) : 0,
      definedOnlyValue: isSet(object.definedOnlyValue)
        ? enumValidationExample_MyEnumFromJSON(object.definedOnlyValue)
        : 0,
      inValue: isSet(object.inValue) ? enumValidationExample_MyEnumFromJSON(object.inValue) : 0,
      notInValue: isSet(object.notInValue) ? enumValidationExample_MyEnumFromJSON(object.notInValue) : 0,
    };
  },

  toJSON(message: EnumValidationExample): unknown {
    const obj: any = {};
    if (message.constValue !== 0) {
      obj.constValue = enumValidationExample_MyEnumToJSON(message.constValue);
    }
    if (message.definedOnlyValue !== 0) {
      obj.definedOnlyValue = enumValidationExample_MyEnumToJSON(message.definedOnlyValue);
    }
    if (message.inValue !== 0) {
      obj.inValue = enumValidationExample_MyEnumToJSON(message.inValue);
    }
    if (message.notInValue !== 0) {
      obj.notInValue = enumValidationExample_MyEnumToJSON(message.notInValue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnumValidationExample>, I>>(base?: I): EnumValidationExample {
    return EnumValidationExample.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnumValidationExample>, I>>(object: I): EnumValidationExample {
    const message = createBaseEnumValidationExample();
    message.constValue = object.constValue ?? 0;
    message.definedOnlyValue = object.definedOnlyValue ?? 0;
    message.inValue = object.inValue ?? 0;
    message.notInValue = object.notInValue ?? 0;
    return message;
  },
};

function createBaseTimestampValidationExample(): TimestampValidationExample {
  return {
    constValue: undefined,
    ltValue: undefined,
    lteValue: undefined,
    ltNowValue: undefined,
    gtValue: undefined,
    gteValue: undefined,
    gtNowValue: undefined,
    withinValue: undefined,
  };
}

export const TimestampValidationExample: MessageFns<TimestampValidationExample> = {
  encode(message: TimestampValidationExample, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.constValue !== undefined) {
      Timestamp.encode(toTimestamp(message.constValue), writer.uint32(10).fork()).join();
    }
    if (message.ltValue !== undefined) {
      Timestamp.encode(toTimestamp(message.ltValue), writer.uint32(18).fork()).join();
    }
    if (message.lteValue !== undefined) {
      Timestamp.encode(toTimestamp(message.lteValue), writer.uint32(26).fork()).join();
    }
    if (message.ltNowValue !== undefined) {
      Timestamp.encode(toTimestamp(message.ltNowValue), writer.uint32(34).fork()).join();
    }
    if (message.gtValue !== undefined) {
      Timestamp.encode(toTimestamp(message.gtValue), writer.uint32(42).fork()).join();
    }
    if (message.gteValue !== undefined) {
      Timestamp.encode(toTimestamp(message.gteValue), writer.uint32(50).fork()).join();
    }
    if (message.gtNowValue !== undefined) {
      Timestamp.encode(toTimestamp(message.gtNowValue), writer.uint32(58).fork()).join();
    }
    if (message.withinValue !== undefined) {
      Timestamp.encode(toTimestamp(message.withinValue), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimestampValidationExample {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimestampValidationExample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.constValue = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ltValue = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.lteValue = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ltNowValue = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.gtValue = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.gteValue = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.gtNowValue = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.withinValue = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimestampValidationExample {
    return {
      constValue: isSet(object.constValue) ? fromJsonTimestamp(object.constValue) : undefined,
      ltValue: isSet(object.ltValue) ? fromJsonTimestamp(object.ltValue) : undefined,
      lteValue: isSet(object.lteValue) ? fromJsonTimestamp(object.lteValue) : undefined,
      ltNowValue: isSet(object.ltNowValue) ? fromJsonTimestamp(object.ltNowValue) : undefined,
      gtValue: isSet(object.gtValue) ? fromJsonTimestamp(object.gtValue) : undefined,
      gteValue: isSet(object.gteValue) ? fromJsonTimestamp(object.gteValue) : undefined,
      gtNowValue: isSet(object.gtNowValue) ? fromJsonTimestamp(object.gtNowValue) : undefined,
      withinValue: isSet(object.withinValue) ? fromJsonTimestamp(object.withinValue) : undefined,
    };
  },

  toJSON(message: TimestampValidationExample): unknown {
    const obj: any = {};
    if (message.constValue !== undefined) {
      obj.constValue = message.constValue.toISOString();
    }
    if (message.ltValue !== undefined) {
      obj.ltValue = message.ltValue.toISOString();
    }
    if (message.lteValue !== undefined) {
      obj.lteValue = message.lteValue.toISOString();
    }
    if (message.ltNowValue !== undefined) {
      obj.ltNowValue = message.ltNowValue.toISOString();
    }
    if (message.gtValue !== undefined) {
      obj.gtValue = message.gtValue.toISOString();
    }
    if (message.gteValue !== undefined) {
      obj.gteValue = message.gteValue.toISOString();
    }
    if (message.gtNowValue !== undefined) {
      obj.gtNowValue = message.gtNowValue.toISOString();
    }
    if (message.withinValue !== undefined) {
      obj.withinValue = message.withinValue.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimestampValidationExample>, I>>(base?: I): TimestampValidationExample {
    return TimestampValidationExample.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimestampValidationExample>, I>>(object: I): TimestampValidationExample {
    const message = createBaseTimestampValidationExample();
    message.constValue = object.constValue ?? undefined;
    message.ltValue = object.ltValue ?? undefined;
    message.lteValue = object.lteValue ?? undefined;
    message.ltNowValue = object.ltNowValue ?? undefined;
    message.gtValue = object.gtValue ?? undefined;
    message.gteValue = object.gteValue ?? undefined;
    message.gtNowValue = object.gtNowValue ?? undefined;
    message.withinValue = object.withinValue ?? undefined;
    return message;
  },
};

function createBaseGoogleApiFieldExample(): GoogleApiFieldExample {
  return { createdAt: undefined, updatedAt: undefined, requiredAt: undefined, optionalAt: undefined };
}

export const GoogleApiFieldExample: MessageFns<GoogleApiFieldExample> = {
  encode(message: GoogleApiFieldExample, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(10).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(18).fork()).join();
    }
    if (message.requiredAt !== undefined) {
      Timestamp.encode(toTimestamp(message.requiredAt), writer.uint32(26).fork()).join();
    }
    if (message.optionalAt !== undefined) {
      Timestamp.encode(toTimestamp(message.optionalAt), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GoogleApiFieldExample {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGoogleApiFieldExample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.requiredAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.optionalAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GoogleApiFieldExample {
    return {
      createdAt: isSet(object.createdAt) ? fromJsonTimestamp(object.createdAt) : undefined,
      updatedAt: isSet(object.updatedAt) ? fromJsonTimestamp(object.updatedAt) : undefined,
      requiredAt: isSet(object.requiredAt) ? fromJsonTimestamp(object.requiredAt) : undefined,
      optionalAt: isSet(object.optionalAt) ? fromJsonTimestamp(object.optionalAt) : undefined,
    };
  },

  toJSON(message: GoogleApiFieldExample): unknown {
    const obj: any = {};
    if (message.createdAt !== undefined) {
      obj.createdAt = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updatedAt = message.updatedAt.toISOString();
    }
    if (message.requiredAt !== undefined) {
      obj.requiredAt = message.requiredAt.toISOString();
    }
    if (message.optionalAt !== undefined) {
      obj.optionalAt = message.optionalAt.toISOString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GoogleApiFieldExample>, I>>(base?: I): GoogleApiFieldExample {
    return GoogleApiFieldExample.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GoogleApiFieldExample>, I>>(object: I): GoogleApiFieldExample {
    const message = createBaseGoogleApiFieldExample();
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.requiredAt = object.requiredAt ?? undefined;
    message.optionalAt = object.optionalAt ?? undefined;
    return message;
  },
};

function createBaseFieldConstraintsExample(): FieldConstraintsExample {
  return { evenValue: 0 };
}

export const FieldConstraintsExample: MessageFns<FieldConstraintsExample> = {
  encode(message: FieldConstraintsExample, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.evenValue !== 0) {
      writer.uint32(8).int32(message.evenValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FieldConstraintsExample {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldConstraintsExample();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.evenValue = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldConstraintsExample {
    return { evenValue: isSet(object.evenValue) ? globalThis.Number(object.evenValue) : 0 };
  },

  toJSON(message: FieldConstraintsExample): unknown {
    const obj: any = {};
    if (message.evenValue !== 0) {
      obj.evenValue = Math.round(message.evenValue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FieldConstraintsExample>, I>>(base?: I): FieldConstraintsExample {
    return FieldConstraintsExample.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FieldConstraintsExample>, I>>(object: I): FieldConstraintsExample {
    const message = createBaseFieldConstraintsExample();
    message.evenValue = object.evenValue ?? 0;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
